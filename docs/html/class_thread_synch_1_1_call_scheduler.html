<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>ThreadSynch: ThreadSynch::CallScheduler&lt; PickupPolicy &gt; Class Template Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.1-p1 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<div class="nav">
<a class="el" href="namespace_thread_synch.html">ThreadSynch</a>::<a class="el" href="class_thread_synch_1_1_call_scheduler.html">CallScheduler</a></div>
<h1>ThreadSynch::CallScheduler&lt; PickupPolicy &gt; Class Template Reference</h1><!-- doxytag: class="ThreadSynch::CallScheduler" -->A singleton class which enables a user to schedule calls across threads The PickupPolicy template parameter will decide how notifications are transported between the threads. <dl class="remark" compact><dt><b>Remarks:</b></dt><dd>Todo:<ul>
<li>Possible tune-up: Keep one lock per queue, in addition to one for all queues. The call structure may become slow in case of many simultaneous and quick routines being called cross threads, in which case the queue mutex will lock and unlock quite rapidly.</li></ul>
</dd></dl>
<ul>
<li>Deal with TLS return values and parameters, if possible. </li></ul>
 
<a href="#_details">More...</a>
<p>
<code>#include &lt;CallScheduler.h&gt;</code>
<p>
Collaboration diagram for ThreadSynch::CallScheduler&lt; PickupPolicy &gt;:<center><font size="2">[<a href="graph_legend.html">legend</a>]</font></center><a href="class_thread_synch_1_1_call_scheduler-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename ReturnValueType, class Exceptions&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">ReturnValueType&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_thread_synch_1_1_call_scheduler.html#989f3e0d31bed40bfcb9bebc21e76011">syncCall</a> (DWORD dwThreadId, boost::function&lt; ReturnValueType()&gt; callback, DWORD dwTimeout)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The function which schedules calls to be made across threads, and expects a few exceptions might be thrown.  <a href="#989f3e0d31bed40bfcb9bebc21e76011"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename ReturnValueType&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">ReturnValueType&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_thread_synch_1_1_call_scheduler.html#989f3e0d31bed40bfcb9bebc21e76011">syncCall</a> (DWORD dwThreadId, boost::function&lt; ReturnValueType()&gt; callback, DWORD dwTimeout)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The function which schedules calls to be made across threads.  <a href="#989f3e0d31bed40bfcb9bebc21e76011"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class Exceptions&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_thread_synch_1_1_call_scheduler.html#fcd34e956d15bb1d6d98ed8555c15dff">syncCall</a> (DWORD dwThreadId, boost::function&lt; void()&gt; callback, DWORD dwTimeout)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The function which schedules calls to be made across threads, and expects a few exceptions might be thrown.  <a href="#fcd34e956d15bb1d6d98ed8555c15dff"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_thread_synch_1_1_call_scheduler.html#fcd34e956d15bb1d6d98ed8555c15dff">syncCall</a> (DWORD dwThreadId, boost::function&lt; void()&gt; callback, DWORD dwTimeout)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The function which schedules calls to be made across threads.  <a href="#fcd34e956d15bb1d6d98ed8555c15dff"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="class_thread_synch_1_1_call_scheduler.html">CallScheduler</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_thread_synch_1_1_call_scheduler.html#337fe8bd1fccbe30b610c5eb094a2ae4">getInstance</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static void APIENTRY&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_thread_synch_1_1_call_scheduler.html#3bf23335dbab7475823385cfb7e868cb">executeScheduledCalls</a> (<a class="el" href="class_thread_synch_1_1_call_scheduler.html">CallScheduler</a> *pSchedulerInstance)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Exceutes all scheuled calls for the current thread.  <a href="#3bf23335dbab7475823385cfb7e868cb"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Private Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef std::list&lt; <a class="el" href="class_thread_synch_1_1_call_handler.html">CallHandler</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_thread_synch_1_1_call_scheduler.html#cbf554f428fb30b6dff3c19449d807f3">CALLQUEUE</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef std::map&lt; DWORD, <a class="el" href="class_thread_synch_1_1_call_scheduler.html#cbf554f428fb30b6dff3c19449d807f3">CALLQUEUE</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_thread_synch_1_1_call_scheduler.html#88b22e5f24ed2fcf26bea54db29091aa">THREADCALLQUEUE</a></td></tr>

<tr><td colspan="2"><br><h2>Private Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_thread_synch_1_1_call_scheduler.html#0715f4fa0b068a6e1c34777b35e2936c">CallScheduler</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor.  <a href="#0715f4fa0b068a6e1c34777b35e2936c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_thread_synch_1_1_call_scheduler.html#3f0fe348a2fb08df5f5a0d1d28522265">executeCallHandler</a> (DWORD dwThreadId, <a class="el" href="class_thread_synch_1_1_call_handler.html">CallHandler</a> *pCallHandler, DWORD dwTimeout)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal helper function shared between the different syncCall flavors.  <a href="#3f0fe348a2fb08df5f5a0d1d28522265"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_thread_synch_1_1_call_scheduler.html#96fe4dfc72728e66e364e94dc4f978f9">CallScheduler</a> (const <a class="el" href="class_thread_synch_1_1_call_scheduler.html">CallScheduler</a> &amp;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy constructor.  <a href="#96fe4dfc72728e66e364e94dc4f978f9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="class_thread_synch_1_1_call_scheduler.html">CallScheduler</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_thread_synch_1_1_call_scheduler.html#381d57f81f2a80fd7cdc706c296a1ee6">operator=</a> (const <a class="el" href="class_thread_synch_1_1_call_scheduler.html">CallScheduler</a> &amp;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assignment operator.  <a href="#381d57f81f2a80fd7cdc706c296a1ee6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_thread_synch_1_1_call_scheduler.html#582a080efb6f92ca0532eb7eec820dfb">enqueueThreadCall</a> (DWORD dwThreadId, <a class="el" href="class_thread_synch_1_1_call_handler.html">CallHandler</a> *pCallback)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">adds a call to the specified therad's queue.  <a href="#582a080efb6f92ca0532eb7eec820dfb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_thread_synch_1_1_call_scheduler.html#e503502d552191ef90a3b0c3dfe53db6">dequeueThreadCall</a> (DWORD dwThreadId, <a class="el" href="class_thread_synch_1_1_call_handler.html">CallHandler</a> *pCallback)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">removes a call off a thread's queue.  <a href="#e503502d552191ef90a3b0c3dfe53db6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_thread_synch_1_1_call_handler.html">CallHandler</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_thread_synch_1_1_call_scheduler.html#13aed07b2a53acffb3448bd014d3a348">getNextCallFromQueue</a> (DWORD dwThreadId, boost::shared_ptr&lt; boost::try_mutex::scoped_try_lock &gt; pCallHandlerLock)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function to fetch the next <a class="el" href="class_thread_synch_1_1_call_handler.html">CallHandler</a> off the specified queue.  <a href="#13aed07b2a53acffb3448bd014d3a348"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Static Private Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_thread_synch_1_1_call_scheduler.html#49c20888be3dda00adb2fa3620fac7fd">onRethrownExceptionDestroyed</a> (boost::shared_ptr&lt; <a class="el" href="class_thread_synch_1_1_call_handler.html">CallHandler</a> &gt; pCallHandler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Callback for CallHandler's rethrow mechanism <dl class="remark" compact><dt><b>Remarks:</b></dt><dd>Will be called by the throwHooked wrapper when a re-thrown exception has been destroyed. The shared_ptr will take care of deleting the <a class="el" href="class_thread_synch_1_1_call_handler.html">CallHandler</a> pointer. </dd></dl>
 <a href="#49c20888be3dda00adb2fa3620fac7fd"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Private Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">boost::mutex&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_thread_synch_1_1_call_scheduler.html#4aaa322f3affe7c26d17a8e639b6e032">m_threadQueueMutex</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_thread_synch_1_1_call_scheduler.html#88b22e5f24ed2fcf26bea54db29091aa">THREADCALLQUEUE</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_thread_synch_1_1_call_scheduler.html#b192ce1ea60ce848a2a5132b59cc155e">m_threadQueue</a></td></tr>

<tr><td colspan="2"><br><h2>Static Private Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="class_thread_synch_1_1_call_scheduler.html">CallScheduler</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_thread_synch_1_1_call_scheduler.html#1a23691056ee42199c546be3d5daf1d9">m_pInstance</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static boost::mutex&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_thread_synch_1_1_call_scheduler.html#6f891f1e2340b23026863754181bb10c">m_instanceMutex</a></td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;class PickupPolicy&gt;<br>
 class ThreadSynch::CallScheduler&lt; PickupPolicy &gt;</h3>

A singleton class which enables a user to schedule calls across threads The PickupPolicy template parameter will decide how notifications are transported between the threads. <dl class="remark" compact><dt><b>Remarks:</b></dt><dd>Todo:<ul>
<li>Possible tune-up: Keep one lock per queue, in addition to one for all queues. The call structure may become slow in case of many simultaneous and quick routines being called cross threads, in which case the queue mutex will lock and unlock quite rapidly.</li></ul>
</dd></dl>
<ul>
<li>Deal with TLS return values and parameters, if possible. </li></ul>

<p>
<hr><h2>Member Typedef Documentation</h2>
<a class="anchor" name="cbf554f428fb30b6dff3c19449d807f3"></a><!-- doxytag: member="ThreadSynch::CallScheduler::CALLQUEUE" ref="cbf554f428fb30b6dff3c19449d807f3" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PickupPolicy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::list&lt;<a class="el" href="class_thread_synch_1_1_call_handler.html">CallHandler</a>*&gt; <a class="el" href="class_thread_synch_1_1_call_scheduler.html">ThreadSynch::CallScheduler</a>&lt; PickupPolicy &gt;::<a class="el" href="class_thread_synch_1_1_call_scheduler.html#cbf554f428fb30b6dff3c19449d807f3">CALLQUEUE</a><code> [private]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="88b22e5f24ed2fcf26bea54db29091aa"></a><!-- doxytag: member="ThreadSynch::CallScheduler::THREADCALLQUEUE" ref="88b22e5f24ed2fcf26bea54db29091aa" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PickupPolicy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::map&lt;DWORD, <a class="el" href="class_thread_synch_1_1_call_scheduler.html#cbf554f428fb30b6dff3c19449d807f3">CALLQUEUE</a>&gt; <a class="el" href="class_thread_synch_1_1_call_scheduler.html">ThreadSynch::CallScheduler</a>&lt; PickupPolicy &gt;::<a class="el" href="class_thread_synch_1_1_call_scheduler.html#88b22e5f24ed2fcf26bea54db29091aa">THREADCALLQUEUE</a><code> [private]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="0715f4fa0b068a6e1c34777b35e2936c"></a><!-- doxytag: member="ThreadSynch::CallScheduler::CallScheduler" ref="0715f4fa0b068a6e1c34777b35e2936c" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PickupPolicy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_thread_synch_1_1_call_scheduler.html">ThreadSynch::CallScheduler</a>&lt; PickupPolicy &gt;::<a class="el" href="class_thread_synch_1_1_call_scheduler.html">CallScheduler</a>           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructor. 
<p>

</div>
</div><p>
<a class="anchor" name="96fe4dfc72728e66e364e94dc4f978f9"></a><!-- doxytag: member="ThreadSynch::CallScheduler::CallScheduler" ref="96fe4dfc72728e66e364e94dc4f978f9" args="(const CallScheduler &amp;)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PickupPolicy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_thread_synch_1_1_call_scheduler.html">ThreadSynch::CallScheduler</a>&lt; PickupPolicy &gt;::<a class="el" href="class_thread_synch_1_1_call_scheduler.html">CallScheduler</a>           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_thread_synch_1_1_call_scheduler.html">CallScheduler</a>&lt; PickupPolicy &gt; &amp;&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copy constructor. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>Not implemented, to avoid copies. </dd></dl>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="337fe8bd1fccbe30b610c5eb094a2ae4"></a><!-- doxytag: member="ThreadSynch::CallScheduler::getInstance" ref="337fe8bd1fccbe30b610c5eb094a2ae4" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PickupPolicy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_thread_synch_1_1_call_scheduler.html">CallScheduler</a>&lt; PickupPolicy &gt; * <a class="el" href="class_thread_synch_1_1_call_scheduler.html">ThreadSynch::CallScheduler</a>&lt; PickupPolicy &gt;::getInstance           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A pointer to the <a class="el" href="class_thread_synch_1_1_call_scheduler.html">CallScheduler</a> implementation. </dd></dl>

</div>
</div><p>
<a class="anchor" name="989f3e0d31bed40bfcb9bebc21e76011"></a><!-- doxytag: member="ThreadSynch::CallScheduler::syncCall" ref="989f3e0d31bed40bfcb9bebc21e76011" args="(DWORD dwThreadId, boost::function&lt; ReturnValueType()&gt; callback, DWORD dwTimeout)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PickupPolicy&gt; </div>
<div class="memtemplate">
template&lt;typename ReturnValueType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ReturnValueType <a class="el" href="class_thread_synch_1_1_call_scheduler.html">ThreadSynch::CallScheduler</a>&lt; PickupPolicy &gt;::syncCall           </td>
          <td>(</td>
          <td class="paramtype">DWORD&nbsp;</td>
          <td class="paramname"> <em>dwThreadId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::function&lt; ReturnValueType()&gt;&nbsp;</td>
          <td class="paramname"> <em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DWORD&nbsp;</td>
          <td class="paramname"> <em>dwTimeout</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The function which schedules calls to be made across threads, and expects a few exceptions might be thrown. 
<p>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>Don't specify "void" for ReturnValueType. Call <a class="el" href="class_thread_synch_1_1_call_scheduler.html#989f3e0d31bed40bfcb9bebc21e76011">syncCall()</a> or syncCall&lt;ExceptionTypes&lt;&gt;&gt; instead. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dwThreadId</em>&nbsp;</td><td>the id of the thread to make the call in. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>callback</em>&nbsp;</td><td>functor which executes the callback. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dwTimeout</em>&nbsp;</td><td>number of milliseconds to wait before terminating. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ReturnValueType</em>&nbsp;</td><td>return value, usually deduced from the boost function. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>Exceptions</em>&nbsp;</td><td>expected exceptions, specified as a comma separated template parameters to ExceptionTypes. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the returned value from the synchronized call. </dd></dl>

</div>
</div><p>
<a class="anchor" name="989f3e0d31bed40bfcb9bebc21e76011"></a><!-- doxytag: member="ThreadSynch::CallScheduler::syncCall" ref="989f3e0d31bed40bfcb9bebc21e76011" args="(DWORD dwThreadId, boost::function&lt; ReturnValueType()&gt; callback, DWORD dwTimeout)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PickupPolicy&gt; </div>
<div class="memtemplate">
template&lt;typename ReturnValueType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ReturnValueType <a class="el" href="class_thread_synch_1_1_call_scheduler.html">ThreadSynch::CallScheduler</a>&lt; PickupPolicy &gt;::syncCall           </td>
          <td>(</td>
          <td class="paramtype">DWORD&nbsp;</td>
          <td class="paramname"> <em>dwThreadId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::function&lt; ReturnValueType()&gt;&nbsp;</td>
          <td class="paramname"> <em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DWORD&nbsp;</td>
          <td class="paramname"> <em>dwTimeout</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The function which schedules calls to be made across threads. 
<p>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>Don't specify "void" for ReturnValueType. Call <a class="el" href="class_thread_synch_1_1_call_scheduler.html#989f3e0d31bed40bfcb9bebc21e76011">syncCall()</a> or syncCall&lt;ExceptionTypes&lt;&gt;&gt; instead. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dwThreadId</em>&nbsp;</td><td>the id of the thread to make the call in. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>callback</em>&nbsp;</td><td>functor which executes the callback. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dwTimeout</em>&nbsp;</td><td>number of milliseconds to wait before terminating. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ReturnValueType</em>&nbsp;</td><td>return value, usually deduced from the boost function. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the returned value from the synchronized call. </dd></dl>

</div>
</div><p>
<a class="anchor" name="fcd34e956d15bb1d6d98ed8555c15dff"></a><!-- doxytag: member="ThreadSynch::CallScheduler::syncCall" ref="fcd34e956d15bb1d6d98ed8555c15dff" args="(DWORD dwThreadId, boost::function&lt; void()&gt; callback, DWORD dwTimeout)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PickupPolicy&gt; </div>
<div class="memtemplate">
template&lt;typename Exceptions&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_thread_synch_1_1_call_scheduler.html">ThreadSynch::CallScheduler</a>&lt; PickupPolicy &gt;::syncCall           </td>
          <td>(</td>
          <td class="paramtype">DWORD&nbsp;</td>
          <td class="paramname"> <em>dwThreadId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::function&lt; void()&gt;&nbsp;</td>
          <td class="paramname"> <em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DWORD&nbsp;</td>
          <td class="paramname"> <em>dwTimeout</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The function which schedules calls to be made across threads, and expects a few exceptions might be thrown. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dwThreadId</em>&nbsp;</td><td>the id of the thread to make the call in. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>callback</em>&nbsp;</td><td>functor which executes the callback. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dwTimeout</em>&nbsp;</td><td>number of milliseconds to wait before terminating. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>Exceptions</em>&nbsp;</td><td>expected exceptions, specified as a comma separated template parameters to ExceptionTypes. </td></tr>
  </table>
</dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This function serves synchronized calls with no (void) return value. </dd></dl>

</div>
</div><p>
<a class="anchor" name="fcd34e956d15bb1d6d98ed8555c15dff"></a><!-- doxytag: member="ThreadSynch::CallScheduler::syncCall" ref="fcd34e956d15bb1d6d98ed8555c15dff" args="(DWORD dwThreadId, boost::function&lt; void()&gt; callback, DWORD dwTimeout)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PickupPolicy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_thread_synch_1_1_call_scheduler.html">ThreadSynch::CallScheduler</a>&lt; PickupPolicy &gt;::syncCall           </td>
          <td>(</td>
          <td class="paramtype">DWORD&nbsp;</td>
          <td class="paramname"> <em>dwThreadId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::function&lt; void()&gt;&nbsp;</td>
          <td class="paramname"> <em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DWORD&nbsp;</td>
          <td class="paramname"> <em>dwTimeout</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The function which schedules calls to be made across threads. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dwThreadId</em>&nbsp;</td><td>the id of the thread to make the call in. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>callback</em>&nbsp;</td><td>functor which executes the callback. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dwTimeout</em>&nbsp;</td><td>number of milliseconds to wait before terminating. </td></tr>
  </table>
</dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This function serves synchronized calls with no (void) return value. </dd></dl>

</div>
</div><p>
<a class="anchor" name="3bf23335dbab7475823385cfb7e868cb"></a><!-- doxytag: member="ThreadSynch::CallScheduler::executeScheduledCalls" ref="3bf23335dbab7475823385cfb7e868cb" args="(CallScheduler *pSchedulerInstance)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PickupPolicy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void APIENTRY <a class="el" href="class_thread_synch_1_1_call_scheduler.html">ThreadSynch::CallScheduler</a>&lt; PickupPolicy &gt;::executeScheduledCalls           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_thread_synch_1_1_call_scheduler.html">CallScheduler</a>&lt; PickupPolicy &gt; *&nbsp;</td>
          <td class="paramname"> <em>pSchedulerInstance</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Exceutes all scheuled calls for the current thread. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pSchedulerInstance</em>&nbsp;</td><td>which singleton instance to run the operations on. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="3f0fe348a2fb08df5f5a0d1d28522265"></a><!-- doxytag: member="ThreadSynch::CallScheduler::executeCallHandler" ref="3f0fe348a2fb08df5f5a0d1d28522265" args="(DWORD dwThreadId, CallHandler *pCallHandler, DWORD dwTimeout)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PickupPolicy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_thread_synch_1_1_call_scheduler.html">ThreadSynch::CallScheduler</a>&lt; PickupPolicy &gt;::executeCallHandler           </td>
          <td>(</td>
          <td class="paramtype">DWORD&nbsp;</td>
          <td class="paramname"> <em>dwThreadId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_thread_synch_1_1_call_handler.html">CallHandler</a> *&nbsp;</td>
          <td class="paramname"> <em>pCallHandler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DWORD&nbsp;</td>
          <td class="paramname"> <em>dwTimeout</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Internal helper function shared between the different syncCall flavors. 
<p>

</div>
</div><p>
<a class="anchor" name="381d57f81f2a80fd7cdc706c296a1ee6"></a><!-- doxytag: member="ThreadSynch::CallScheduler::operator=" ref="381d57f81f2a80fd7cdc706c296a1ee6" args="(const CallScheduler &amp;)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PickupPolicy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_thread_synch_1_1_call_scheduler.html">CallScheduler</a>&amp; <a class="el" href="class_thread_synch_1_1_call_scheduler.html">ThreadSynch::CallScheduler</a>&lt; PickupPolicy &gt;::operator=           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_thread_synch_1_1_call_scheduler.html">CallScheduler</a>&lt; PickupPolicy &gt; &amp;&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assignment operator. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>Not implemented, to avoid copies. </dd></dl>

</div>
</div><p>
<a class="anchor" name="582a080efb6f92ca0532eb7eec820dfb"></a><!-- doxytag: member="ThreadSynch::CallScheduler::enqueueThreadCall" ref="582a080efb6f92ca0532eb7eec820dfb" args="(DWORD dwThreadId, CallHandler *pCallback)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PickupPolicy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_thread_synch_1_1_call_scheduler.html">ThreadSynch::CallScheduler</a>&lt; PickupPolicy &gt;::enqueueThreadCall           </td>
          <td>(</td>
          <td class="paramtype">DWORD&nbsp;</td>
          <td class="paramname"> <em>dwThreadId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_thread_synch_1_1_call_handler.html">CallHandler</a> *&nbsp;</td>
          <td class="paramname"> <em>pCallback</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
adds a call to the specified therad's queue. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dwThreadId</em>&nbsp;</td><td>the id of the thread to enqueue in. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pCallback</em>&nbsp;</td><td>pointer to a <a class="el" href="class_thread_synch_1_1_call_handler.html">CallHandler</a> instance in which the details of the callback functor resides. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="e503502d552191ef90a3b0c3dfe53db6"></a><!-- doxytag: member="ThreadSynch::CallScheduler::dequeueThreadCall" ref="e503502d552191ef90a3b0c3dfe53db6" args="(DWORD dwThreadId, CallHandler *pCallback)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PickupPolicy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_thread_synch_1_1_call_scheduler.html">ThreadSynch::CallScheduler</a>&lt; PickupPolicy &gt;::dequeueThreadCall           </td>
          <td>(</td>
          <td class="paramtype">DWORD&nbsp;</td>
          <td class="paramname"> <em>dwThreadId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_thread_synch_1_1_call_handler.html">CallHandler</a> *&nbsp;</td>
          <td class="paramname"> <em>pCallback</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
removes a call off a thread's queue. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dwThreadId</em>&nbsp;</td><td>the id of the thread to enqueue in. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pCallback</em>&nbsp;</td><td>pointer to a <a class="el" href="class_thread_synch_1_1_call_handler.html">CallHandler</a> instance in which the details of the callback functor resides. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="13aed07b2a53acffb3448bd014d3a348"></a><!-- doxytag: member="ThreadSynch::CallScheduler::getNextCallFromQueue" ref="13aed07b2a53acffb3448bd014d3a348" args="(DWORD dwThreadId, boost::shared_ptr&lt; boost::try_mutex::scoped_try_lock &gt; pCallHandlerLock)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PickupPolicy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_thread_synch_1_1_call_handler.html">CallHandler</a> * <a class="el" href="class_thread_synch_1_1_call_scheduler.html">ThreadSynch::CallScheduler</a>&lt; PickupPolicy &gt;::getNextCallFromQueue           </td>
          <td>(</td>
          <td class="paramtype">DWORD&nbsp;</td>
          <td class="paramname"> <em>dwThreadId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::shared_ptr&lt; boost::try_mutex::scoped_try_lock &gt;&nbsp;</td>
          <td class="paramname"> <em>pCallHandlerLock</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Function to fetch the next <a class="el" href="class_thread_synch_1_1_call_handler.html">CallHandler</a> off the specified queue. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dwThreadId</em>&nbsp;</td><td>the id of the thread to get a call for. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pCallHandlerLock</em>&nbsp;</td><td>a lock object, which has locked a resource in the <a class="el" href="class_thread_synch_1_1_call_handler.html">CallHandler</a> for simultaneous access. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The next scheduled <a class="el" href="class_thread_synch_1_1_call_handler.html">CallHandler</a>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="49c20888be3dda00adb2fa3620fac7fd"></a><!-- doxytag: member="ThreadSynch::CallScheduler::onRethrownExceptionDestroyed" ref="49c20888be3dda00adb2fa3620fac7fd" args="(boost::shared_ptr&lt; CallHandler &gt; pCallHandler)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PickupPolicy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="class_thread_synch_1_1_call_scheduler.html">ThreadSynch::CallScheduler</a>&lt; PickupPolicy &gt;::onRethrownExceptionDestroyed           </td>
          <td>(</td>
          <td class="paramtype">boost::shared_ptr&lt; <a class="el" href="class_thread_synch_1_1_call_handler.html">CallHandler</a> &gt;&nbsp;</td>
          <td class="paramname"> <em>pCallHandler</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, static, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Callback for CallHandler's rethrow mechanism <dl class="remark" compact><dt><b>Remarks:</b></dt><dd>Will be called by the throwHooked wrapper when a re-thrown exception has been destroyed. The shared_ptr will take care of deleting the <a class="el" href="class_thread_synch_1_1_call_handler.html">CallHandler</a> pointer. </dd></dl>

<p>

</div>
</div><p>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="1a23691056ee42199c546be3d5daf1d9"></a><!-- doxytag: member="ThreadSynch::CallScheduler::m_pInstance" ref="1a23691056ee42199c546be3d5daf1d9" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PickupPolicy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_thread_synch_1_1_call_scheduler.html">CallScheduler</a>&lt; PickupPolicy &gt; * <a class="el" href="class_thread_synch_1_1_call_scheduler.html">ThreadSynch::CallScheduler</a>&lt; PickupPolicy &gt;::<a class="el" href="class_thread_synch_1_1_call_scheduler.html#1a23691056ee42199c546be3d5daf1d9">m_pInstance</a><code> [static, private]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="6f891f1e2340b23026863754181bb10c"></a><!-- doxytag: member="ThreadSynch::CallScheduler::m_instanceMutex" ref="6f891f1e2340b23026863754181bb10c" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PickupPolicy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::mutex <a class="el" href="class_thread_synch_1_1_call_scheduler.html">ThreadSynch::CallScheduler</a>&lt; PickupPolicy &gt;::<a class="el" href="class_thread_synch_1_1_call_scheduler.html#6f891f1e2340b23026863754181bb10c">m_instanceMutex</a><code> [static, private]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="4aaa322f3affe7c26d17a8e639b6e032"></a><!-- doxytag: member="ThreadSynch::CallScheduler::m_threadQueueMutex" ref="4aaa322f3affe7c26d17a8e639b6e032" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PickupPolicy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::mutex <a class="el" href="class_thread_synch_1_1_call_scheduler.html">ThreadSynch::CallScheduler</a>&lt; PickupPolicy &gt;::<a class="el" href="class_thread_synch_1_1_call_scheduler.html#4aaa322f3affe7c26d17a8e639b6e032">m_threadQueueMutex</a><code> [private]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="b192ce1ea60ce848a2a5132b59cc155e"></a><!-- doxytag: member="ThreadSynch::CallScheduler::m_threadQueue" ref="b192ce1ea60ce848a2a5132b59cc155e" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PickupPolicy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_thread_synch_1_1_call_scheduler.html#88b22e5f24ed2fcf26bea54db29091aa">THREADCALLQUEUE</a> <a class="el" href="class_thread_synch_1_1_call_scheduler.html">ThreadSynch::CallScheduler</a>&lt; PickupPolicy &gt;::<a class="el" href="class_thread_synch_1_1_call_scheduler.html#b192ce1ea60ce848a2a5132b59cc155e">m_threadQueue</a><code> [private]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li>ThreadSynch/<a class="el" href="_call_scheduler_8h.html">CallScheduler.h</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on Tue Mar 13 23:06:21 2007 for ThreadSynch by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.1-p1 </small></address>
</body>
</html>
