<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>ThreadSynch: ThreadSynch Namespace Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.1-p1 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li id="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="namespaces.html"><span>Namespace List</span></a></li>
    <li><a href="namespacemembers.html"><span>Namespace&nbsp;Members</span></a></li>
  </ul></div>
<h1>ThreadSynch Namespace Reference</h1>
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_thread_synch_1_1_a_p_c_pickup_policy.html">APCPickupPolicy</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_thread_synch_1_1_call_handler.html">CallHandler</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A class which stores information about a cross thread call. This class will keep a functor with bound parameters prior to a synchronized call, and provide a return value and exception information upon completion.  <a href="class_thread_synch_1_1_call_handler.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_thread_synch_1_1_call_scheduler.html">CallScheduler</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A singleton class which enables a user to schedule calls across threads The PickupPolicy template parameter will decide how notifications are transported between the threads.  <a href="class_thread_synch_1_1_call_scheduler.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_thread_synch_1_1_call_scheduling_failed_exception.html">CallSchedulingFailedException</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">thrown when some undefined factor stops the scheduled call from running. <dl class="remark" compact><dt><b>Remarks:</b></dt><dd>Todo: Improve on the base exception class, to provide better message passing options </dd></dl>
 <a href="class_thread_synch_1_1_call_scheduling_failed_exception.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_thread_synch_1_1_call_timeout_exception.html">CallTimeoutException</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">thrown when a scheduled call times out.  <a href="class_thread_synch_1_1_call_timeout_exception.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_thread_synch_1_1_unexpected_exception.html">UnexpectedException</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">thrown when a scheduled call throws an exception which wasn't expected by the user.  <a href="class_thread_synch_1_1_unexpected_exception.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_thread_synch_1_1_functor_retval_binder.html">FunctorRetvalBinder</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A helper functor and return value class. A helper class which stores the call functor, and attempts to grab the return value after a successful call. <a class="el" href="class_thread_synch_1_1_call_handler.html">CallHandler</a> cannot be templated without major pain in the rest of the code, so this templated type does the work.  <a href="class_thread_synch_1_1_functor_retval_binder.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_thread_synch_1_1_future.html">Future</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_thread_synch_1_1_future_3_01void_01_4.html">Future&lt; void &gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_thread_synch_1_1_future___impl.html">Future_Impl</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_thread_synch_1_1_future___impl_3_01void_01_4.html">Future_Impl&lt; void &gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_thread_synch_1_1_future___impl_3_01_t_01_5_01_4.html">Future_Impl&lt; T * &gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_thread_synch_1_1_future___impl_3_01_t_01_6_01_4.html">Future_Impl&lt; T &amp; &gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_thread_synch_1_1_future_value_pending.html">FutureValuePending</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">thrown when <a class="el" href="class_thread_synch_1_1_future.html#85d7656bec9ed41c8f9d73c065957958">Future::getValue</a> is called on a <a class="el" href="class_thread_synch_1_1_future.html">Future</a> object which has not yet been computed. <dl class="remark" compact><dt><b>Remarks:</b></dt><dd>Todo: Improve on the base exception class, to provide better message passing options </dd></dl>
 <a href="class_thread_synch_1_1_future_value_pending.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_thread_synch_1_1_pickup_policy_provider.html">PickupPolicyProvider</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_thread_synch_1_1_pickup_scheduling_failed_exception.html">PickupSchedulingFailedException</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">thrown when a pickup policy fails.  <a href="class_thread_synch_1_1_pickup_scheduling_failed_exception.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_thread_synch_1_1_w_m_pickup_policy.html">WMPickupPolicy</a></td></tr>

<tr><td colspan="2"><br><h2>Namespaces</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_thread_synch_1_1details.html">details</a></td></tr>

<tr><td colspan="2"><br><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_thread_synch.html#150d223e3c96b6f53e91dc80129260d9">ASYNCH_CALL_STATUS</a> { <a class="el" href="namespace_thread_synch.html#150d223e3c96b6f53e91dc80129260d9b120308dc2055cc7bd0874e6028fae4b">ASYNCH_CALL_ERROR</a>, 
<a class="el" href="namespace_thread_synch.html#150d223e3c96b6f53e91dc80129260d958d0c5e9cf46b9e1b5c894e03f40f43b">ASYNCH_CALL_PENDING</a>, 
<a class="el" href="namespace_thread_synch.html#150d223e3c96b6f53e91dc80129260d993b610542b2d0bf1d32d484f5752a2f6">ASYNCH_CALL_COMPLETE</a>, 
<a class="el" href="namespace_thread_synch.html#150d223e3c96b6f53e91dc80129260d9a56ea58d899b60b8cdec7ae29e1a471e">ASYNCH_CALL_ABORTED</a>
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Describes the status of a future call.  <a href="namespace_thread_synch.html#150d223e3c96b6f53e91dc80129260d9">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">boost::disable_if&lt; IS_VOID_OR_SEQUENCE(ReturnValueType), <a class="el" href="class_thread_synch_1_1_future.html">Future</a>&lt;<br>
 ReturnValueType &gt;&gt;::type <br>
<a class="el" href="class_thread_synch_1_1_call_scheduler.html">CallScheduler</a>&lt; PickupPolicy <br>
&gt;::asyncCall(DWORD dwThreadId,<br>
 boost::function&lt; ReturnValueType()&gt; <br>
callback){boost::shared_ptr&lt;<br>
 <a class="el" href="class_thread_synch_1_1_call_handler.html">CallHandler</a> &gt; pCallHandler(new <a class="el" href="class_thread_synch_1_1_call_handler.html">CallHandler</a>());<a class="el" href="class_thread_synch_1_1_future.html">Future</a>&lt;<br>
 ReturnValueType &gt; futureObject=<a class="el" href="class_thread_synch_1_1_future.html">Future</a>&lt; ReturnValueType <br>
&gt;boost::bind(&amp;<a class="el" href="class_thread_synch_1_1_call_scheduler.html">CallScheduler</a>&lt;<br>
 PickupPolicy &gt;::abortAsyncCall,<br>
 this, dwThreadId, pCallHandler),<br>
 boost::bind(&amp;<a class="el" href="class_thread_synch_1_1_call_scheduler.html">CallScheduler</a>&lt;<br>
 PickupPolicy &gt;::waitAsyncCall,<br>
 this, pCallHandler, _1),<br>
 boost::bind(&amp;CallHandler::getReturnValue&lt;<br>
 ReturnValueType &gt;, pCallHandler.get()));pCallHandler-&gt;setCallFunctor&lt;<br>
 ReturnValueType, Exceptions <br>
&gt;callback);preProcessAsynchronousCallHandler(dwThreadId, pCallHandler.get());return futureObject;}template&lt;<br>
 class PickupPolicy &gt; template&lt;<br>
 typename ReturnValueType,<br>
 class Exceptions &gt; typename <br>
boost::enable_if&lt; boost::is_void&lt;<br>
 ReturnValueType &gt;, <a class="el" href="class_thread_synch_1_1_future.html">Future</a>&lt;<br>
 ReturnValueType &gt;&gt;::type <br>
<a class="el" href="class_thread_synch_1_1_call_scheduler.html">CallScheduler</a>&lt; PickupPolicy <br>
&gt;::asyncCall(DWORD dwThreadId,<br>
 boost::function&lt; ReturnValueType()&gt; <br>
callback){boost::shared_ptr&lt;<br>
 <a class="el" href="class_thread_synch_1_1_call_handler.html">CallHandler</a> &gt; pCallHandler(new <a class="el" href="class_thread_synch_1_1_call_handler.html">CallHandler</a>());<a class="el" href="class_thread_synch_1_1_future.html">Future</a>&lt;<br>
 ReturnValueType &gt; futureObject=<a class="el" href="class_thread_synch_1_1_future.html">Future</a>&lt; ReturnValueType <br>
&gt;boost::bind(&amp;<a class="el" href="class_thread_synch_1_1_call_scheduler.html">CallScheduler</a>&lt;<br>
 PickupPolicy &gt;::abortAsyncCall,<br>
 this, dwThreadId, pCallHandler),<br>
 boost::bind(&amp;<a class="el" href="class_thread_synch_1_1_call_scheduler.html">CallScheduler</a>&lt;<br>
 PickupPolicy &gt;::waitAsyncCall,<br>
 this, pCallHandler, _1));pCallHandler-&gt;setCallFunctor&lt;<br>
 ReturnValueType, Exceptions <br>
&gt;callback);preProcessAsynchronousCallHandler(dwThreadId, pCallHandler.get());return futureObject;}template&lt;<br>
 class PickupPolicy &gt; <a class="el" href="class_thread_synch_1_1_call_scheduler.html">CallScheduler</a>&lt;<br>
 PickupPolicy &gt;::<a class="el" href="class_thread_synch_1_1_call_scheduler.html">CallScheduler</a>(){}template&lt; class PickupPolicy <br>
&gt; <a class="el" href="namespace_thread_synch.html#150d223e3c96b6f53e91dc80129260d9">ASYNCH_CALL_STATUS</a> <a class="el" href="class_thread_synch_1_1_call_scheduler.html">CallScheduler</a>&lt;<br>
 PickupPolicy &gt;::abortAsyncCall(DWORD dwThreadId, boost::shared_ptr&lt;<br>
 <a class="el" href="class_thread_synch_1_1_call_handler.html">CallHandler</a> &gt; pCallHandler){boost::scoped_ptr&lt; boost::try_mutex::scoped_lock <br>
&gt; pCallHandlerLock;pCallHandlerLock.reset(new boost::try_mutex::scoped_lock(*pCallHandler-&gt;getAccessMutex()));if(pCallHandler-&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_thread_synch.html#28f67842c67137234a540c0c2c0452c4">isCompleted</a> )())</td></tr>

</table>
<hr><h2>Enumeration Type Documentation</h2>
<a class="anchor" name="150d223e3c96b6f53e91dc80129260d9"></a><!-- doxytag: member="ThreadSynch::ASYNCH_CALL_STATUS" ref="150d223e3c96b6f53e91dc80129260d9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespace_thread_synch.html#150d223e3c96b6f53e91dc80129260d9">ThreadSynch::ASYNCH_CALL_STATUS</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Describes the status of a future call. 
<p>
<dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="150d223e3c96b6f53e91dc80129260d9b120308dc2055cc7bd0874e6028fae4b"></a><!-- doxytag: member="ASYNCH_CALL_ERROR" ref="150d223e3c96b6f53e91dc80129260d9b120308dc2055cc7bd0874e6028fae4b" args="" -->ASYNCH_CALL_ERROR</em>&nbsp;</td><td>
Indicates an error condition. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="150d223e3c96b6f53e91dc80129260d958d0c5e9cf46b9e1b5c894e03f40f43b"></a><!-- doxytag: member="ASYNCH_CALL_PENDING" ref="150d223e3c96b6f53e91dc80129260d958d0c5e9cf46b9e1b5c894e03f40f43b" args="" -->ASYNCH_CALL_PENDING</em>&nbsp;</td><td>
Indicates that the computation is still pending. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="150d223e3c96b6f53e91dc80129260d993b610542b2d0bf1d32d484f5752a2f6"></a><!-- doxytag: member="ASYNCH_CALL_COMPLETE" ref="150d223e3c96b6f53e91dc80129260d993b610542b2d0bf1d32d484f5752a2f6" args="" -->ASYNCH_CALL_COMPLETE</em>&nbsp;</td><td>
Indicates that the computation has completed. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="150d223e3c96b6f53e91dc80129260d9a56ea58d899b60b8cdec7ae29e1a471e"></a><!-- doxytag: member="ASYNCH_CALL_ABORTED" ref="150d223e3c96b6f53e91dc80129260d9a56ea58d899b60b8cdec7ae29e1a471e" args="" -->ASYNCH_CALL_ABORTED</em>&nbsp;</td><td>
Indicates that the computation has been aborted (successfully). </td></tr>
</table>
</dl>

</div>
</div><p>
<hr><h2>Variable Documentation</h2>
<a class="anchor" name="28f67842c67137234a540c0c2c0452c4"></a><!-- doxytag: member="ThreadSynch::isCompleted" ref="28f67842c67137234a540c0c2c0452c4" args=")())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::disable_if&lt;IS_VOID_OR_SEQUENCE(ReturnValueType), <a class="el" href="class_thread_synch_1_1_future.html">Future</a>&lt;ReturnValueType&gt;&gt;:: type <a class="el" href="class_thread_synch_1_1_call_scheduler.html">CallScheduler</a>&lt;PickupPolicy&gt;::asyncCall(DWORD dwThreadId, boost::function&lt;ReturnValueType()&gt; callback) { boost::shared_ptr&lt;<a class="el" href="class_thread_synch_1_1_call_handler.html">CallHandler</a>&gt; pCallHandler(new <a class="el" href="class_thread_synch_1_1_call_handler.html">CallHandler</a>()); <a class="el" href="class_thread_synch_1_1_future.html">Future</a>&lt;ReturnValueType&gt; futureObject = <a class="el" href="class_thread_synch_1_1_future.html">Future</a>&lt;ReturnValueType&gt;boost::bind(&amp;<a class="el" href="class_thread_synch_1_1_call_scheduler.html">CallScheduler</a>&lt;PickupPolicy&gt;::abortAsyncCall, this, dwThreadId, pCallHandler), boost::bind(&amp;<a class="el" href="class_thread_synch_1_1_call_scheduler.html">CallScheduler</a>&lt;PickupPolicy&gt;::waitAsyncCall, this, pCallHandler, _1), boost::bind(&amp;CallHandler::getReturnValue&lt;ReturnValueType&gt;, pCallHandler.get())); pCallHandler-&gt;setCallFunctor&lt;ReturnValueType, Exceptions&gt;callback); preProcessAsynchronousCallHandler(dwThreadId, pCallHandler.get()); return futureObject; } template&lt;class PickupPolicy&gt; template&lt;typename ReturnValueType, class Exceptions&gt; typename boost::enable_if&lt;boost::is_void&lt;ReturnValueType&gt;, <a class="el" href="class_thread_synch_1_1_future.html">Future</a>&lt;ReturnValueType&gt;&gt;:: type <a class="el" href="class_thread_synch_1_1_call_scheduler.html">CallScheduler</a>&lt;PickupPolicy&gt;::asyncCall(DWORD dwThreadId, boost::function&lt;ReturnValueType()&gt; callback) { boost::shared_ptr&lt;<a class="el" href="class_thread_synch_1_1_call_handler.html">CallHandler</a>&gt; pCallHandler(new <a class="el" href="class_thread_synch_1_1_call_handler.html">CallHandler</a>()); <a class="el" href="class_thread_synch_1_1_future.html">Future</a>&lt;ReturnValueType&gt; futureObject = <a class="el" href="class_thread_synch_1_1_future.html">Future</a>&lt;ReturnValueType&gt;boost::bind(&amp;<a class="el" href="class_thread_synch_1_1_call_scheduler.html">CallScheduler</a>&lt;PickupPolicy&gt;::abortAsyncCall, this, dwThreadId, pCallHandler), boost::bind(&amp;<a class="el" href="class_thread_synch_1_1_call_scheduler.html">CallScheduler</a>&lt;PickupPolicy&gt;::waitAsyncCall, this, pCallHandler, _1)); pCallHandler-&gt;setCallFunctor&lt;ReturnValueType, Exceptions&gt;callback); preProcessAsynchronousCallHandler(dwThreadId, pCallHandler.get()); return futureObject; } template&lt;class PickupPolicy&gt; <a class="el" href="class_thread_synch_1_1_call_scheduler.html">CallScheduler</a>&lt;PickupPolicy&gt;::<a class="el" href="class_thread_synch_1_1_call_scheduler.html">CallScheduler</a>() { } template&lt;class PickupPolicy&gt; <a class="el" href="namespace_thread_synch.html#150d223e3c96b6f53e91dc80129260d9">ASYNCH_CALL_STATUS</a> <a class="el" href="class_thread_synch_1_1_call_scheduler.html">CallScheduler</a>&lt;PickupPolicy&gt;::abortAsyncCall(DWORD dwThreadId, boost::shared_ptr&lt;<a class="el" href="class_thread_synch_1_1_call_handler.html">CallHandler</a>&gt; pCallHandler) { boost::scoped_ptr&lt;boost::try_mutex::scoped_lock&gt; pCallHandlerLock; pCallHandlerLock.reset(new boost::try_mutex::scoped_lock(*pCallHandler-&gt;getAccessMutex())); if(pCallHandler- <a class="el" href="namespace_thread_synch.html#28f67842c67137234a540c0c2c0452c4">ThreadSynch::isCompleted</a>)())          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr size="1"><address style="align: right;"><small>Generated on Wed Aug 1 15:23:57 2007 for ThreadSynch by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.1-p1 </small></address>
</body>
</html>
