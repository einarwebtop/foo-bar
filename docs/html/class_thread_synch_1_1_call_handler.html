<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>ThreadSynch: ThreadSynch::CallHandler Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.1-p1 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<div class="nav">
<a class="el" href="namespace_thread_synch.html">ThreadSynch</a>::<a class="el" href="class_thread_synch_1_1_call_handler.html">CallHandler</a></div>
<h1>ThreadSynch::CallHandler Class Reference</h1><!-- doxytag: class="ThreadSynch::CallHandler" -->A class which stores information about a cross thread call. This class will keep a functor with bound parameters prior to a synchronized call, and provide a return value and exception information upon completion.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;CallHandler.h&gt;</code>
<p>
<a href="class_thread_synch_1_1_call_handler-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_thread_synch_1_1_call_handler.html#00596b487225875df620860225cbdaff">CallHandler</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_thread_synch_1_1_call_handler.html#babec161e856179c27dd9f4876ba64d2">~CallHandler</a> ()</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T, class E&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_thread_synch_1_1_call_handler.html#828f3f6b9d0ff47e8c79aba7b2934de9">setCallFunctor</a> (boost::function&lt; T()&gt; func)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">function which sets the callback functor to be run.  <a href="#828f3f6b9d0ff47e8c79aba7b2934de9"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class E&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_thread_synch_1_1_call_handler.html#55d65e7e9cf77f09d97d1c234cab63f2">setCallFunctor</a> (boost::function&lt; void()&gt; func)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_thread_synch_1_1_call_handler.html#44b5abe6a6f02e16d2a4d937ed2edc9d">waitForCompletion</a> (DWORD dwTimeout) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Waits for completion.  <a href="#44b5abe6a6f02e16d2a4d937ed2edc9d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_thread_synch_1_1_call_handler.html#f956917892782e2e93770f0ce949b930">executeCallback</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Executes the scheduled function. The scheduled function is executed and the return value is set.  <a href="#f956917892782e2e93770f0ce949b930"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_thread_synch_1_1_call_handler.html#783d9b823407890a9db6204dbe8c0547">isCompleted</a> () const</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the status of the scheduled call.  <a href="#783d9b823407890a9db6204dbe8c0547"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_thread_synch_1_1_call_handler.html#503f40467d67c5e66d75d7e4adc982f2">caughtException</a> () const</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">T&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_thread_synch_1_1_call_handler.html#a2d19cdb118b95b47c1e0c721543165b">getReturnValue</a> () const</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the stored return value.  <a href="#a2d19cdb118b95b47c1e0c721543165b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_thread_synch_1_1_call_handler.html#b82c52296707e77be495b73d9dfb840d">rethrowException</a> (boost::function&lt; void()&gt; onExceptionDestroyed)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Rethrows an exception thrown by the exception expecter.  <a href="#b82c52296707e77be495b73d9dfb840d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">boost::try_mutex *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_thread_synch_1_1_call_handler.html#fba6f20d909a441bf26f398acb08d00d">getAccessMutex</a> () const</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Opens up for locks on the structure.  <a href="#fba6f20d909a441bf26f398acb08d00d"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Private Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_thread_synch_1_1_call_handler.html#0d085c7496eb484faf759febc3a2cb30">onExceptionExpecterComplete</a> (<a class="el" href="namespace_thread_synch_1_1details.html#f73d76ac70172e118a84433ebadd17c1">details::CaughtExceptionType</a> etype)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">notification that the scheduled call handled threw an exception  <a href="#0d085c7496eb484faf759febc3a2cb30"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Private Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">HANDLE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_thread_synch_1_1_call_handler.html#8ed861e5e20506ff96046d79f24f2df2">m_hCompletedEvent</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">boost::scoped_array&lt; BYTE &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_thread_synch_1_1_call_handler.html#cae5d7c277b1c5eeb585dada696c0775">m_pReturnValue</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">boost::function&lt; void()&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_thread_synch_1_1_call_handler.html#3073947e9e8cdd3505cfd6f97c146ffd">m_executeCall</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">boost::function&lt; void(boost::function&lt;<br>
 void()&gt;)&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_thread_synch_1_1_call_handler.html#0c9302eaa21ec02b3acb566cd92f1ab6">m_rethrowException</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">boost::function&lt; void()&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_thread_synch_1_1_call_handler.html#7e6ad0e53a411868267ac2626b3fa45f">m_freeRetvalBinder</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">boost::function&lt; void()&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_thread_synch_1_1_call_handler.html#25ccedc0706f1d48f1bcee659cfd9d41">m_freeExceptionExpecter</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">boost::try_mutex&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_thread_synch_1_1_call_handler.html#0b8aa60b33c1b4bb8f5294da8f41f18a">m_accessMutex</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_thread_synch_1_1_call_handler.html#8c6ab458b8da6323d0b55291777523b2">m_bCallFunctorSet</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_thread_synch_1_1_call_handler.html#507812e48192ed1397fcbb38311649ab">m_bExceptionCaught</a></td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
A class which stores information about a cross thread call. This class will keep a functor with bound parameters prior to a synchronized call, and provide a return value and exception information upon completion. 
<p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="00596b487225875df620860225cbdaff"></a><!-- doxytag: member="ThreadSynch::CallHandler::CallHandler" ref="00596b487225875df620860225cbdaff" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ThreadSynch::CallHandler::CallHandler           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructor 
</div>
</div><p>
<a class="anchor" name="babec161e856179c27dd9f4876ba64d2"></a><!-- doxytag: member="ThreadSynch::CallHandler::~CallHandler" ref="babec161e856179c27dd9f4876ba64d2" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ThreadSynch::CallHandler::~CallHandler           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destructor 
</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="828f3f6b9d0ff47e8c79aba7b2934de9"></a><!-- doxytag: member="ThreadSynch::CallHandler::setCallFunctor" ref="828f3f6b9d0ff47e8c79aba7b2934de9" args="(boost::function&lt; T()&gt; func)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ThreadSynch::CallHandler::setCallFunctor           </td>
          <td>(</td>
          <td class="paramtype">boost::function&lt; T()&gt;&nbsp;</td>
          <td class="paramname"> <em>func</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
function which sets the callback functor to be run. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>func</em>&nbsp;</td><td>A functor which accepts no parameters, and returns a type T or no value at all (void). </td></tr>
  </table>
</dl>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>All functor parameters must be bound with boost::bind. </dd></dl>

</div>
</div><p>
<a class="anchor" name="55d65e7e9cf77f09d97d1c234cab63f2"></a><!-- doxytag: member="ThreadSynch::CallHandler::setCallFunctor" ref="55d65e7e9cf77f09d97d1c234cab63f2" args="(boost::function&lt; void()&gt; func)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ThreadSynch::CallHandler::setCallFunctor           </td>
          <td>(</td>
          <td class="paramtype">boost::function&lt; void()&gt;&nbsp;</td>
          <td class="paramname"> <em>func</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="44b5abe6a6f02e16d2a4d937ed2edc9d"></a><!-- doxytag: member="ThreadSynch::CallHandler::waitForCompletion" ref="44b5abe6a6f02e16d2a4d937ed2edc9d" args="(DWORD dwTimeout) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL ThreadSynch::CallHandler::waitForCompletion           </td>
          <td>(</td>
          <td class="paramtype">DWORD&nbsp;</td>
          <td class="paramname"> <em>dwTimeout</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Waits for completion. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dwTimeout</em>&nbsp;</td><td>Time span in milliseconds to wait for completion. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Status for the call. </dd></dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>TRUE</em>&nbsp;</td><td>indicates that the call has completed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>FALSE</em>&nbsp;</td><td>indicates that the call has not been completed. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="f956917892782e2e93770f0ce949b930"></a><!-- doxytag: member="ThreadSynch::CallHandler::executeCallback" ref="f956917892782e2e93770f0ce949b930" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ThreadSynch::CallHandler::executeCallback           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Executes the scheduled function. The scheduled function is executed and the return value is set. 
<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>When the call completes, an event will be signaled to indicate that the call has completed. This event will be set regardless of whether or not the scheduled call throws an exception. </dd></dl>

</div>
</div><p>
<a class="anchor" name="783d9b823407890a9db6204dbe8c0547"></a><!-- doxytag: member="ThreadSynch::CallHandler::isCompleted" ref="783d9b823407890a9db6204dbe8c0547" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL ThreadSynch::CallHandler::isCompleted           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the status of the scheduled call. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Completion status. </dd></dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>TRUE</em>&nbsp;</td><td>if the call has been made. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>FALSE</em>&nbsp;</td><td>if the call has not yet been made. </td></tr>
  </table>
</dl>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>Will return TRUE even if an exception was thrown by the call. Use <a class="el" href="class_thread_synch_1_1_call_handler.html#503f40467d67c5e66d75d7e4adc982f2">caughtException()</a> to find whether or not an exception was caught. </dd></dl>

</div>
</div><p>
<a class="anchor" name="503f40467d67c5e66d75d7e4adc982f2"></a><!-- doxytag: member="ThreadSynch::CallHandler::caughtException" ref="503f40467d67c5e66d75d7e4adc982f2" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL ThreadSynch::CallHandler::caughtException           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Whether or not the scheduled call threw an exception </dd></dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>TRUE</em>&nbsp;</td><td>if an exception was thrown and caught </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>FALSE</em>&nbsp;</td><td>if no exception was thrown </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="a2d19cdb118b95b47c1e0c721543165b"></a><!-- doxytag: member="ThreadSynch::CallHandler::getReturnValue" ref="a2d19cdb118b95b47c1e0c721543165b" args="() const" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T ThreadSynch::CallHandler::getReturnValue           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the stored return value. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The return value as stored by the call. </dd></dl>

</div>
</div><p>
<a class="anchor" name="b82c52296707e77be495b73d9dfb840d"></a><!-- doxytag: member="ThreadSynch::CallHandler::rethrowException" ref="b82c52296707e77be495b73d9dfb840d" args="(boost::function&lt; void()&gt; onExceptionDestroyed)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ThreadSynch::CallHandler::rethrowException           </td>
          <td>(</td>
          <td class="paramtype">boost::function&lt; void()&gt;&nbsp;</td>
          <td class="paramname"> <em>onExceptionDestroyed</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Rethrows an exception thrown by the exception expecter. 
<p>

</div>
</div><p>
<a class="anchor" name="fba6f20d909a441bf26f398acb08d00d"></a><!-- doxytag: member="ThreadSynch::CallHandler::getAccessMutex" ref="fba6f20d909a441bf26f398acb08d00d" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::try_mutex* ThreadSynch::CallHandler::getAccessMutex           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Opens up for locks on the structure. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A try_mutex for this structure, which can either be scoped_try_lock'ed or scoped_lock'ed. </dd></dl>

</div>
</div><p>
<a class="anchor" name="0d085c7496eb484faf759febc3a2cb30"></a><!-- doxytag: member="ThreadSynch::CallHandler::onExceptionExpecterComplete" ref="0d085c7496eb484faf759febc3a2cb30" args="(details::CaughtExceptionType etype)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ThreadSynch::CallHandler::onExceptionExpecterComplete           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_thread_synch_1_1details.html#f73d76ac70172e118a84433ebadd17c1">details::CaughtExceptionType</a>&nbsp;</td>
          <td class="paramname"> <em>etype</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
notification that the scheduled call handled threw an exception 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>etype</em>&nbsp;</td><td>Specifies which exception, if any, was thrown </td></tr>
  </table>
</dl>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>Called by the exception expecter when a call has been completed, in context of the thread that does the pickup. </dd></dl>

</div>
</div><p>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="8ed861e5e20506ff96046d79f24f2df2"></a><!-- doxytag: member="ThreadSynch::CallHandler::m_hCompletedEvent" ref="8ed861e5e20506ff96046d79f24f2df2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HANDLE <a class="el" href="class_thread_synch_1_1_call_handler.html#8ed861e5e20506ff96046d79f24f2df2">ThreadSynch::CallHandler::m_hCompletedEvent</a><code> [private]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
An inner event handle which signals completion. 
</div>
</div><p>
<a class="anchor" name="cae5d7c277b1c5eeb585dada696c0775"></a><!-- doxytag: member="ThreadSynch::CallHandler::m_pReturnValue" ref="cae5d7c277b1c5eeb585dada696c0775" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::scoped_array&lt;BYTE&gt; <a class="el" href="class_thread_synch_1_1_call_handler.html#cae5d7c277b1c5eeb585dada696c0775">ThreadSynch::CallHandler::m_pReturnValue</a><code> [private]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Memory block which receives and stores the return value of the scheduled function. 
</div>
</div><p>
<a class="anchor" name="3073947e9e8cdd3505cfd6f97c146ffd"></a><!-- doxytag: member="ThreadSynch::CallHandler::m_executeCall" ref="3073947e9e8cdd3505cfd6f97c146ffd" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::function&lt;void()&gt; <a class="el" href="class_thread_synch_1_1_call_handler.html#3073947e9e8cdd3505cfd6f97c146ffd">ThreadSynch::CallHandler::m_executeCall</a><code> [private]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A functor which executes the call and attempts to retrieve the return value. 
</div>
</div><p>
<a class="anchor" name="0c9302eaa21ec02b3acb566cd92f1ab6"></a><!-- doxytag: member="ThreadSynch::CallHandler::m_rethrowException" ref="0c9302eaa21ec02b3acb566cd92f1ab6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::function&lt;void(boost::function&lt;void()&gt;)&gt; <a class="el" href="class_thread_synch_1_1_call_handler.html#0c9302eaa21ec02b3acb566cd92f1ab6">ThreadSynch::CallHandler::m_rethrowException</a><code> [private]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A functor which rethrows exceptions picked up by the expecter. The functor accepts one parameter, which is another functor to be called as a thrown exception object is destroyed. 
</div>
</div><p>
<a class="anchor" name="7e6ad0e53a411868267ac2626b3fa45f"></a><!-- doxytag: member="ThreadSynch::CallHandler::m_freeRetvalBinder" ref="7e6ad0e53a411868267ac2626b3fa45f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::function&lt;void()&gt; <a class="el" href="class_thread_synch_1_1_call_handler.html#7e6ad0e53a411868267ac2626b3fa45f">ThreadSynch::CallHandler::m_freeRetvalBinder</a><code> [private]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A functor which instructs the retval binder class to free itself -- needed since we cannot reference the class without full template parameter information. 
</div>
</div><p>
<a class="anchor" name="25ccedc0706f1d48f1bcee659cfd9d41"></a><!-- doxytag: member="ThreadSynch::CallHandler::m_freeExceptionExpecter" ref="25ccedc0706f1d48f1bcee659cfd9d41" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::function&lt;void()&gt; <a class="el" href="class_thread_synch_1_1_call_handler.html#25ccedc0706f1d48f1bcee659cfd9d41">ThreadSynch::CallHandler::m_freeExceptionExpecter</a><code> [private]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A functor which instructs the exception expecter class to free itself -- needed since we cannot reference the class without full template parameter information. 
</div>
</div><p>
<a class="anchor" name="0b8aa60b33c1b4bb8f5294da8f41f18a"></a><!-- doxytag: member="ThreadSynch::CallHandler::m_accessMutex" ref="0b8aa60b33c1b4bb8f5294da8f41f18a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::try_mutex <a class="el" href="class_thread_synch_1_1_call_handler.html#0b8aa60b33c1b4bb8f5294da8f41f18a">ThreadSynch::CallHandler::m_accessMutex</a><code> [mutable, private]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Inner mutex which provides locking functionality on the structure. 
</div>
</div><p>
<a class="anchor" name="8c6ab458b8da6323d0b55291777523b2"></a><!-- doxytag: member="ThreadSynch::CallHandler::m_bCallFunctorSet" ref="8c6ab458b8da6323d0b55291777523b2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL <a class="el" href="class_thread_synch_1_1_call_handler.html#8c6ab458b8da6323d0b55291777523b2">ThreadSynch::CallHandler::m_bCallFunctorSet</a><code> [private]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Indicates whether or not setCallFunctor has been called already 
</div>
</div><p>
<a class="anchor" name="507812e48192ed1397fcbb38311649ab"></a><!-- doxytag: member="ThreadSynch::CallHandler::m_bExceptionCaught" ref="507812e48192ed1397fcbb38311649ab" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL <a class="el" href="class_thread_synch_1_1_call_handler.html#507812e48192ed1397fcbb38311649ab">ThreadSynch::CallHandler::m_bExceptionCaught</a><code> [private]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Indicates whether or not an exception was thrown by the call 
</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li>ThreadSynch/<a class="el" href="_call_handler_8h.html">CallHandler.h</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on Tue Mar 13 23:06:21 2007 for ThreadSynch by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.1-p1 </small></address>
</body>
</html>
