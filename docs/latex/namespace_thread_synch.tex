\section{Thread\-Synch Namespace Reference}
\label{namespace_thread_synch}\index{ThreadSynch@{ThreadSynch}}


\subsection*{Classes}
\begin{CompactItemize}
\item 
class {\bf APCPickup\-Policy}
\item 
class {\bf Call\-Handler}
\begin{CompactList}\small\item\em A class which stores information about a cross thread call. This class will keep a functor with bound parameters prior to a synchronized call, and provide a return value and exception information upon completion. \item\end{CompactList}\item 
class {\bf Call\-Scheduler}
\begin{CompactList}\small\item\em A singleton class which enables a user to schedule calls across threads The Pickup\-Policy template parameter will decide how notifications are transported between the threads. \item\end{CompactList}\item 
class {\bf Call\-Scheduling\-Failed\-Exception}
\begin{CompactList}\small\item\em thrown when some undefined factor stops the scheduled call from running. \begin{Desc}
\item[Remarks:]Todo: Improve on the base exception class, to provide better message passing options \end{Desc}
\item\end{CompactList}\item 
class {\bf Call\-Timeout\-Exception}
\begin{CompactList}\small\item\em thrown when a scheduled call times out. \item\end{CompactList}\item 
class {\bf Unexpected\-Exception}
\begin{CompactList}\small\item\em thrown when a scheduled call throws an exception which wasn't expected by the user. \item\end{CompactList}\item 
class {\bf Functor\-Retval\-Binder}
\begin{CompactList}\small\item\em A helper functor and return value class. A helper class which stores the call functor, and attempts to grab the return value after a successful call. \doxyref{Call\-Handler}{p.}{class_thread_synch_1_1_call_handler} cannot be templated without major pain in the rest of the code, so this templated type does the work. \item\end{CompactList}\item 
class {\bf Future}
\item 
class {\bf Future$<$ void $>$}
\item 
class {\bf Future\_\-Impl}
\item 
class {\bf Future\_\-Impl$<$ void $>$}
\item 
class {\bf Future\_\-Impl$<$ T $\ast$ $>$}
\item 
class {\bf Future\_\-Impl$<$ T \& $>$}
\item 
class {\bf Future\-Value\-Pending}
\begin{CompactList}\small\item\em thrown when \doxyref{Future::get\-Value}{p.}{class_thread_synch_1_1_future_85d7656bec9ed41c8f9d73c065957958} is called on a \doxyref{Future}{p.}{class_thread_synch_1_1_future} object which has not yet been computed. \begin{Desc}
\item[Remarks:]Todo: Improve on the base exception class, to provide better message passing options \end{Desc}
\item\end{CompactList}\item 
class {\bf Pickup\-Policy\-Provider}
\item 
class {\bf Pickup\-Scheduling\-Failed\-Exception}
\begin{CompactList}\small\item\em thrown when a pickup policy fails. \item\end{CompactList}\item 
class {\bf WMPickup\-Policy}
\end{CompactItemize}
\subsection*{Namespaces}
\begin{CompactItemize}
\item 
namespace {\bf details}
\end{CompactItemize}
\subsection*{Enumerations}
\begin{CompactItemize}
\item 
enum {\bf ASYNCH\_\-CALL\_\-STATUS} \{ {\bf ASYNCH\_\-CALL\_\-ERROR}, 
{\bf ASYNCH\_\-CALL\_\-PENDING}, 
{\bf ASYNCH\_\-CALL\_\-COMPLETE}, 
{\bf ASYNCH\_\-CALL\_\-ABORTED}
 \}
\begin{CompactList}\small\item\em Describes the status of a future call. \item\end{CompactList}\end{CompactItemize}
\subsection*{Variables}
\begin{CompactItemize}
\item 
boost::disable\_\-if$<$ IS\_\-VOID\_\-OR\_\-SEQUENCE(Return\-Value\-Type), {\bf Future}$<$ Return\-Value\-Type $>$$>$::type {\bf Call\-Scheduler}$<$ Pickup\-Policy $>$::async\-Call(DWORD dw\-Thread\-Id, boost::function$<$ Return\-Value\-Type()$>$ callback)\{boost::shared\_\-ptr$<$ {\bf Call\-Handler} $>$ p\-Call\-Handler(new {\bf Call\-Handler}());{\bf Future}$<$ Return\-Value\-Type $>$ future\-Object={\bf Future}$<$ Return\-Value\-Type $>$boost::bind(\&{\bf Call\-Scheduler}$<$ Pickup\-Policy $>$::abort\-Async\-Call, this, dw\-Thread\-Id, p\-Call\-Handler), boost::bind(\&{\bf Call\-Scheduler}$<$ Pickup\-Policy $>$::wait\-Async\-Call, this, p\-Call\-Handler, \_\-1), boost::bind(\&Call\-Handler::get\-Return\-Value$<$ Return\-Value\-Type $>$, p\-Call\-Handler.get()));p\-Call\-Handler $\rightarrow$ set\-Call\-Functor$<$ Return\-Value\-Type, Exceptions $>$callback);pre\-Process\-Asynchronous\-Call\-Handler(dw\-Thread\-Id, p\-Call\-Handler.get());return future\-Object;\}template$<$ class Pickup\-Policy $>$ template$<$ typename Return\-Value\-Type, class Exceptions $>$ typename boost::enable\_\-if$<$ boost::is\_\-void$<$ Return\-Value\-Type $>$, {\bf Future}$<$ Return\-Value\-Type $>$$>$::type {\bf Call\-Scheduler}$<$ Pickup\-Policy $>$::async\-Call(DWORD dw\-Thread\-Id, boost::function$<$ Return\-Value\-Type()$>$ callback)\{boost::shared\_\-ptr$<$ {\bf Call\-Handler} $>$ p\-Call\-Handler(new {\bf Call\-Handler}());{\bf Future}$<$ Return\-Value\-Type $>$ future\-Object={\bf Future}$<$ Return\-Value\-Type $>$boost::bind(\&{\bf Call\-Scheduler}$<$ Pickup\-Policy $>$::abort\-Async\-Call, this, dw\-Thread\-Id, p\-Call\-Handler), boost::bind(\&{\bf Call\-Scheduler}$<$ Pickup\-Policy $>$::wait\-Async\-Call, this, p\-Call\-Handler, \_\-1));p\-Call\-Handler $\rightarrow$ set\-Call\-Functor$<$ Return\-Value\-Type, Exceptions $>$callback);pre\-Process\-Asynchronous\-Call\-Handler(dw\-Thread\-Id, p\-Call\-Handler.get());return future\-Object;\}template$<$ class Pickup\-Policy $>$ {\bf Call\-Scheduler}$<$ Pickup\-Policy $>$::{\bf Call\-Scheduler}()\{\}template$<$ class Pickup\-Policy $>$ {\bf ASYNCH\_\-CALL\_\-STATUS} {\bf Call\-Scheduler}$<$ Pickup\-Policy $>$::abort\-Async\-Call(DWORD dw\-Thread\-Id, boost::shared\_\-ptr$<$ {\bf Call\-Handler} $>$ p\-Call\-Handler)\{boost::scoped\_\-ptr$<$ boost::try\_\-mutex::scoped\_\-lock $>$ p\-Call\-Handler\-Lock;p\-Call\-Handler\-Lock.reset(new boost::try\_\-mutex::scoped\_\-lock($\ast$p\-Call\-Handler $\rightarrow$ get\-Access\-Mutex()));if(p\-Call\-Handler- {\bf is\-Completed} )())
\end{CompactItemize}


\subsection{Enumeration Type Documentation}
\index{ThreadSynch@{Thread\-Synch}!ASYNCH_CALL_STATUS@{ASYNCH\_\-CALL\_\-STATUS}}
\index{ASYNCH_CALL_STATUS@{ASYNCH\_\-CALL\_\-STATUS}!ThreadSynch@{Thread\-Synch}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}enum {\bf Thread\-Synch::ASYNCH\_\-CALL\_\-STATUS}}\label{namespace_thread_synch_150d223e3c96b6f53e91dc80129260d9}


Describes the status of a future call. 

\begin{Desc}
\item[Enumerator: ]\par
\begin{description}
\index{ASYNCH_CALL_ERROR@{ASYNCH\_\-CALL\_\-ERROR}!ThreadSynch@{ThreadSynch}}\index{ThreadSynch@{ThreadSynch}!ASYNCH_CALL_ERROR@{ASYNCH\_\-CALL\_\-ERROR}}\item[{\em 
ASYNCH\_\-CALL\_\-ERROR\label{namespace_thread_synch_150d223e3c96b6f53e91dc80129260d9b120308dc2055cc7bd0874e6028fae4b}
}]Indicates an error condition. \index{ASYNCH_CALL_PENDING@{ASYNCH\_\-CALL\_\-PENDING}!ThreadSynch@{ThreadSynch}}\index{ThreadSynch@{ThreadSynch}!ASYNCH_CALL_PENDING@{ASYNCH\_\-CALL\_\-PENDING}}\item[{\em 
ASYNCH\_\-CALL\_\-PENDING\label{namespace_thread_synch_150d223e3c96b6f53e91dc80129260d958d0c5e9cf46b9e1b5c894e03f40f43b}
}]Indicates that the computation is still pending. \index{ASYNCH_CALL_COMPLETE@{ASYNCH\_\-CALL\_\-COMPLETE}!ThreadSynch@{ThreadSynch}}\index{ThreadSynch@{ThreadSynch}!ASYNCH_CALL_COMPLETE@{ASYNCH\_\-CALL\_\-COMPLETE}}\item[{\em 
ASYNCH\_\-CALL\_\-COMPLETE\label{namespace_thread_synch_150d223e3c96b6f53e91dc80129260d993b610542b2d0bf1d32d484f5752a2f6}
}]Indicates that the computation has completed. \index{ASYNCH_CALL_ABORTED@{ASYNCH\_\-CALL\_\-ABORTED}!ThreadSynch@{ThreadSynch}}\index{ThreadSynch@{ThreadSynch}!ASYNCH_CALL_ABORTED@{ASYNCH\_\-CALL\_\-ABORTED}}\item[{\em 
ASYNCH\_\-CALL\_\-ABORTED\label{namespace_thread_synch_150d223e3c96b6f53e91dc80129260d9a56ea58d899b60b8cdec7ae29e1a471e}
}]Indicates that the computation has been aborted (successfully). \end{description}
\end{Desc}



\subsection{Variable Documentation}
\index{ThreadSynch@{Thread\-Synch}!isCompleted@{isCompleted}}
\index{isCompleted@{isCompleted}!ThreadSynch@{Thread\-Synch}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}boost::disable\_\-if$<$IS\_\-VOID\_\-OR\_\-SEQUENCE(Return\-Value\-Type), {\bf Future}$<$Return\-Value\-Type$>$$>$:: type {\bf Call\-Scheduler}$<$Pickup\-Policy$>$::async\-Call(DWORD dw\-Thread\-Id, boost::function$<$Return\-Value\-Type()$>$ callback) \{ boost::shared\_\-ptr$<${\bf Call\-Handler}$>$ p\-Call\-Handler(new {\bf Call\-Handler}()); {\bf Future}$<$Return\-Value\-Type$>$ future\-Object = {\bf Future}$<$Return\-Value\-Type$>$boost::bind(\&{\bf Call\-Scheduler}$<$Pickup\-Policy$>$::abort\-Async\-Call, this, dw\-Thread\-Id, p\-Call\-Handler), boost::bind(\&{\bf Call\-Scheduler}$<$Pickup\-Policy$>$::wait\-Async\-Call, this, p\-Call\-Handler, \_\-1), boost::bind(\&Call\-Handler::get\-Return\-Value$<$Return\-Value\-Type$>$, p\-Call\-Handler.get())); p\-Call\-Handler $\rightarrow$ set\-Call\-Functor$<$Return\-Value\-Type, Exceptions$>$callback); pre\-Process\-Asynchronous\-Call\-Handler(dw\-Thread\-Id, p\-Call\-Handler.get()); return future\-Object; \} template$<$class Pickup\-Policy$>$ template$<$typename Return\-Value\-Type, class Exceptions$>$ typename boost::enable\_\-if$<$boost::is\_\-void$<$Return\-Value\-Type$>$, {\bf Future}$<$Return\-Value\-Type$>$$>$:: type {\bf Call\-Scheduler}$<$Pickup\-Policy$>$::async\-Call(DWORD dw\-Thread\-Id, boost::function$<$Return\-Value\-Type()$>$ callback) \{ boost::shared\_\-ptr$<${\bf Call\-Handler}$>$ p\-Call\-Handler(new {\bf Call\-Handler}()); {\bf Future}$<$Return\-Value\-Type$>$ future\-Object = {\bf Future}$<$Return\-Value\-Type$>$boost::bind(\&{\bf Call\-Scheduler}$<$Pickup\-Policy$>$::abort\-Async\-Call, this, dw\-Thread\-Id, p\-Call\-Handler), boost::bind(\&{\bf Call\-Scheduler}$<$Pickup\-Policy$>$::wait\-Async\-Call, this, p\-Call\-Handler, \_\-1)); p\-Call\-Handler $\rightarrow$ set\-Call\-Functor$<$Return\-Value\-Type, Exceptions$>$callback); pre\-Process\-Asynchronous\-Call\-Handler(dw\-Thread\-Id, p\-Call\-Handler.get()); return future\-Object; \} template$<$class Pickup\-Policy$>$ {\bf Call\-Scheduler}$<$Pickup\-Policy$>$::{\bf Call\-Scheduler}() \{ \} template$<$class Pickup\-Policy$>$ {\bf ASYNCH\_\-CALL\_\-STATUS} {\bf Call\-Scheduler}$<$Pickup\-Policy$>$::abort\-Async\-Call(DWORD dw\-Thread\-Id, boost::shared\_\-ptr$<${\bf Call\-Handler}$>$ p\-Call\-Handler) \{ boost::scoped\_\-ptr$<$boost::try\_\-mutex::scoped\_\-lock$>$ p\-Call\-Handler\-Lock; p\-Call\-Handler\-Lock.reset(new boost::try\_\-mutex::scoped\_\-lock($\ast$p\-Call\-Handler $\rightarrow$ get\-Access\-Mutex())); if(p\-Call\-Handler- {\bf Thread\-Synch::is\-Completed})())}\label{namespace_thread_synch_28f67842c67137234a540c0c2c0452c4}


